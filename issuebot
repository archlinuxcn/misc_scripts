#!/usr/bin/python3

import datetime
import sys
import os
import pathlib
import subprocess
import shutil
from typing import List
from enum import auto, Enum

from ruamel.yaml import round_trip_dump
from ruamel.yaml.util import load_yaml_guess_indent

from github import GitHub
from myutils import file_lock

from lilac2.lilacyaml import iter_pkgdir

from webhooks.issue import parse_issue_text

REQUEST_WAITING_TIME = datetime.timedelta(days=30)
ORPHANING_WAITING_TIME = datetime.timedelta(days=14)
OFFICIAL_WAITING_TIME = datetime.timedelta(days=4)

LILAC_LOCK = os.path.expanduser('~/.lilac/.lock')
REPO = pathlib.Path('~/archgitrepo/archlinuxcn').expanduser()

ORPHANED_PACKAGES_BREAKDOWN = 5

def git_push() -> None:
  while True:
    try:
      subprocess.check_output(['git', 'push'], cwd=REPO)
      break
    except subprocess.CalledProcessError as e:
      if 'non-fast-forward' in e.output or 'fetch first' in e.output:
        subprocess.check_call(["git", "pull", "--rebase"])
      else:
        sys.stdout.write(e.output)
        raise

def process_package_requests(
  gh: GitHub, repo: str, now: datetime.datetime,
) -> None:
  for issue in gh.get_repo_issues(repo, labels='package-request'):
    if now - issue.updated_at > REQUEST_WAITING_TIME:
      print(f'Marking {issue} as failed')
      issue.comment('''\
请求太久无回应，关闭。

This request has been waiting for too long, closing.''')
      issue.add_labels(['request-failed'])
      issue.close()

class OrphanResult(Enum):
  Removed = auto()
  NonExistent = auto()

def process_one_orphaned(name: str) -> OrphanResult:
  try:
    shutil.rmtree(REPO / name)
  except FileNotFoundError:
    return OrphanResult.NonExistent
  else:
    subprocess.check_call(['git', 'add', name], cwd=REPO)
    return OrphanResult.Removed

def process_orphaned_packages(
  gh: GitHub, repo: str, now: datetime.datetime,
) -> None:
  issues = [issue for issue in gh.get_repo_issues(repo, labels='orphaning')
            if now - issue.updated_at > ORPHANING_WAITING_TIME
            and 'seen-by-lilac' not in issue.labels]

  for issue in issues:
    print(f'Removing orphaned {issue}')
    _issuetype, packages = parse_issue_text(issue.body)
    if not packages:
      issue.comment('''\
lilac 无法解析出涉及的软件包名，请手动处理。

lilac can't parse out the relevant package names, please handle manually.''')
      issue.add_labels(['seen-by-lilac'])
      continue

    changed = False

    with file_lock(LILAC_LOCK):
      subprocess.check_output(['git', 'pull'], cwd=REPO)

      for name in packages:
        if process_one_orphaned(name) != OrphanResult.NonExistent:
          changed = True

      if changed:
        msg = None
        if len(packages) > ORPHANED_PACKAGES_BREAKDOWN:
          affected = "\n".join(f"- {x}" for x in packages)
          msg = f'''Removing {len(packages)} packages \
due to being orphaned for a long time.

Affected packages:
{affected}

closes #{issue.number}'''
        else:
          msg = f'{", ".join(packages)}: orphaned for a long time, removing. closes #{issue.number}'
        subprocess.check_output(['git', 'commit', '-m', msg], cwd=REPO)
        git_push()

    if changed:
      issue.comment('''\
已自动删除。

Automatically removed.''')
    else:
      issue.comment('''\
已被删除。

Already removed.''')
      issue.close()

def remove_repo_depends(pkgdir: pathlib.Path, packages: List[str]) -> bool:
  # use ruamel.yaml for yaml manipulation with preserving indents and comments
  lilac_yaml_path = pkgdir / 'lilac.yaml'

  with open(lilac_yaml_path) as f:
    lilac_yaml, indent, block_seq_indent = load_yaml_guess_indent(f.read())

  repo_depends = lilac_yaml.get('repo_depends', [])
  if not repo_depends:
    return False

  # Find out all repo_depends entries to remove. Not using list comprehension
  # here so that comments are preserved.
  target_indexes = []
  for idx, repo_depend in enumerate(repo_depends):
    if isinstance(repo_depend, dict):
      repo_depend = list(repo_depend.keys())[0]
    if repo_depend in packages:
      target_indexes.append(idx)

  if target_indexes:
    for target_idx in sorted(target_indexes, reverse=True):
      del lilac_yaml['repo_depends'][target_idx]
    if len(lilac_yaml['repo_depends']) == 0:
      del lilac_yaml['repo_depends']
    with open(lilac_yaml_path, 'w') as f:
      round_trip_dump(lilac_yaml, stream=f, indent=indent,
                      block_seq_indent=block_seq_indent)
    subprocess.check_call(['git', 'add', pkgdir.name], cwd=REPO)
    return True
  else:
    return False

def process_in_official(
  gh: GitHub, repo: str, now: datetime.datetime,
) -> None:
  issues = [
    issue for issue in gh.get_repo_issues(
      repo, labels='in-official-repos')
    if now - issue.updated_at > OFFICIAL_WAITING_TIME
    and 'seen-by-lilac' not in issue.labels
  ]

  for issue in issues:
    print(f'Removing in-official-repos {issue}')
    _issuetype, packages = parse_issue_text(issue.body)
    if not packages:
      issue.comment('''\
lilac 无法解析出涉及的软件包名，请手动处理。

lilac can't parse out the relevant package names, please handle manually.''')
      issue.add_labels(['seen-by-lilac'])
      continue

    changed = False

    with file_lock(LILAC_LOCK):
      subprocess.check_output(['git', 'pull'], cwd=REPO)

      for pkgdir in iter_pkgdir(REPO):
        if remove_repo_depends(pkgdir, packages):
          changed = True

      for name in packages:
        try:
          shutil.rmtree(REPO / name)
        except FileNotFoundError:
          pass
        else:
          subprocess.check_call(['git', 'add', name], cwd=REPO)
          changed = True

      if changed:
        msg = None
        if len(packages) > ORPHANED_PACKAGES_BREAKDOWN:
          affected = "\n".join(f"- {x}" for x in packages)
          msg = f'''Removing {len(packages)} packages \
and corresponding repo_depends entries because they are already in official repos.

Affected packages:
{affected}

closes #{issue.number}'''
        else:
          msg = f'{", ".join(packages)}: in official repos, removing packages and repo_depends entries if any. closes #{issue.number}'
        subprocess.check_output(['git', 'commit', '-m', msg], cwd=REPO)
        git_push()

    if changed:
      issue.comment('''\
已自动删除。

Automatically removed.''')
    else:
      issue.comment('''\
已被删除。

Already removed.''')
      issue.close()

def main() -> None:
  token = os.environ['GITHUB_TOKEN']
  gh = GitHub(token)
  repo = 'archlinuxcn/repo'
  now = datetime.datetime.now(datetime.timezone.utc)

  process_package_requests(gh, repo, now)
  process_orphaned_packages(gh, repo, now)
  process_in_official(gh, repo, now)

if __name__ == '__main__':
  main()
